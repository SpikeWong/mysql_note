# 高性能 Mysql

## 存储引擎

### MyISAM

- 崩溃修复: 执行表修复可能导致部分数据丢失
- 表锁：支持读取时并发插入(CONCURRENT INSERT)
- 索引：支持全文索引，支持延迟更新索引（每次修改完成后，不会立刻将修改的索引数据写入磁盘）

### innoDB

- 支持事务
- 支持自动崩溃恢复
- 锁： 支持表锁和行级锁（相较于表锁有更高的并发度但是消耗更多的系统资源），通过 MVCC 提高并发度
- 支持4种隔离级别：默认为 REPEATABLE READ(可重复读)，并且通过间隙锁防止幻读的出现
- 索引： 支持聚簇索引（数据根据主键顺序进行排列），聚簇索引多主键查询有很高的性能，二级索引必须包含主键列

## 性能分析与测试

### 通过性能剖析进行优化

- 基于执行时间的性能分析
- 基于等待的性能分析

### 理解性能剖析

- 值得优化的查询： 不要对一个占总响应时间 5% 的查询进行优化
- 异常情况:  执行次数较少，但速度慢，占总响应时间不突出
- 丢失的时间： 测量工具存在系统误差，导致 cpu 实际执行的时间 > 测得的时间
- 被隐藏的细节： 平均响应时间会隐藏掉很多的细节，分析时应结合直方图，百分比，标准差等指标一起进行分析
- mysql 性能剖析工具推荐： pt-query-digest

### 对应用程序进行性能剖析

- 应用程序可能存在的性能问题

	- 外部资源，比如调用了 HTTP 请求
	- 需要处理大量的数据，比如分析超大的 XML 文件
	- 在循环中执行昂贵的操作，比如滥用正则表达式
	- 使用了低效的算法，比如使用了暴力搜索算法
	- 应用程序性能剖析工具推荐: New Relic

### 剖析 Mysql 查询

- 剖析服务器负载

	- 慢查询日志

		- 开销最低，精度最高的·查询时间的工具，开启慢查询日志带来的磁盘 I/O 消耗可以忽略不计，而空间消耗可以通过定期 rotation 日志解决
		- 分析方法

			- 通过慢查询日志查询
			- 当权限不足无法在服务器查看时

				- pt-query-digest --processlist
				- 先通过 tcpdump 将网络数据包保存到磁盘，然后使用 pt-query-digest --type=tcpdump

		- 分析过程

			- 自顶向下分析

				- 使用 pt-query-digest --explain 分析慢查询日志，通过 V/M（离差指数） 列以及执行计划一般都能发现性能较低的查询

- 剖析单条查询

	- Show Profile

		- 功能: 在服务器上执行的所有语句，都会测量其耗费的时间和其他一些查询执行状态变更相关的数据
		- 使用方法 : 1. set profiling = 1; 2.select * from x;  3.show profiles; 
		- tip: profile 告诉我们在哪个部分耗费了最多的时间，但是并不会告诉我们为什么会这样

	- show status

		- 功能： 返回一些计数器，包括服务器级别的全局计数器（show global status），和基于会话级别的计数器（show status），部分全局级别的计数器也会存在 show status 中
		- 使用方法: 1.flush status; 2.select * from x; 3.show status where variable like 'Handler%' pr variable like 'Created%'
		- tip: show status 大部分结果都只是一个计数器，可以显示某些活动如读索引的频繁程度，但无法给出消耗了多少时间。最有用的计数器包括句柄计数器，临时文件和表计数器。使用 explain 虽然也可以获得大部分相同的信息，但explain 只是估计的结果

	- performane_schema

		- 书中未详细说明，好奇通过 performance_schema 如何进行分析可查看 https://www.cnblogs.com/cchust/p/5061131.html
		- tip: 开启 performance_schema 会有较大性能损耗, ≈10%

- 诊断间歇性问题

	- 间歇性问题往往需要花费更多的时间，此时需要在问题发生的地方通过观察资源的使用情况，并尽可能地测量数据，尽量不要采用试错的方式
	- 单条查询还是服务器问题

		- 所有程序变慢，又突然变好，每一条查询都变慢了，那么可能不是慢查询的原因。如果服务器整体运行没有问题，只有某条查询偶尔变慢，那么将注意力放到这条特定的查询上
		- show global status 持续观察 thread_running, thread_connected. queries。当每秒查询数（thread_running）下跌，而其他两个至少一个出现尖刺则说明服务器可能存在问题。

- 其他剖析工具

	- user_statistics 表

		- percona 和 maridb 支持: SET GLOBAL userstat=1;

	- strace

		- 使用 strace 可以调查系统调用的情况, 其中使用 strace -cfp $(pidof mysqld) 可以查看调用的时间，当使用 strace 时会使 mysql 变慢

- 总结

	- 1.定义性能最有效的方法是响应时间
	- 2.优化基于高质量，全方位，完整的测量
	- 3.测量的最佳点是应用程序
	- 4.完整的测量需要大量的数据，所以需要剖析工具
	- 5.大量的剖析工具只能统计 cpu 工作的时间，而不能统计 io 等待的时间，所以等待分析是很好的补充
	- 6.等优化的成本大于优化带来的提升时，停止优化

## schema 与数据类型优化

### 选择优化的数据类型

- 1.更小更好：选择正确存储数据的最小数据类型
- 2.简单就好：简单的数据类型通常需要更少的 cpu 周期。比如整型比字符串操作代价更低
- 3.尽量避免 Null：null 会使索引占用更多的存储空间，变得低效。所以尽可能设置默认值

### 整数类型

- 为 INT 类型指定宽度对大多数应用是没有意义的，它不会限制值的合法范围，只是规定了 Mysql 的一些交互工具显示字符的个数

### 实数类型

- DECIMAL 相比 DOUBLE 和 FLOAT 需要额外的空间和计算开销，所以应该只在需要精确计算的时候使用 DECIMAL

### 字符串类型

- varchar 需要使用1个或2个额外的字节保存字符串的长度，当 update 数据且页内没有足够空间时 innodb 会页分裂 
- 当字符串的最大长度比平均长度大很多时选择 varchar 更合适
- BLOB 和 TEXT 类型是为了存储很大的数据而设计的字符串类型，分别采用二进制和字符串方式存储。当 BLOB 和 TEXT 值太大时，Innodb 会使用专门的外部存储区域来进行存储。当对 BLOB 和 TEXT 进行排序时，只对 max_sort_length 指定的这部分字符串进行排序。Mysql 无法对 BLOB 和 TEXT 列全部长度进行索引
- 使用枚举值替代常用的字符串类型，mysql 在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节

### 日期和时间类型

- DATETIME: 与时区无关，8 个字节空间。精度为秒
- TIMESTAMP: 与时区有关，1970 1 月 1 日午夜以来的描述， 4 个字节存储空间。默认 NOT NULL，插入记录时没有指定第一个 TIMESTAMP 列值时，默认设置为当前时间，更新时未指定 当前值，也会默认更新为当前时间

### 位数据类型

- BIT: 最大长度为 64 位。MYISAM 会打包存储 BIT 字段。如果有 17 个单独的 BIT 列只需要 17 个位存储。如果是 innodb 或者 memory 引擎，会为每个 BIT 列使用一个足够存储的最小证书类型来存放，所以不能节省存储空间。
- SET: 在 mysql 内部以一系列的打包的位的集合来表示。通过 FIND_IN_SET() 和 FIELD() 这样的函数进行查询，在 set 列上无法通过索引查询.

### id

- 不仅要考虑存储类型，还要考虑 MYSQL 对这种类型如何执行计算和比较
- 混用不用类型可能导致性能问题或者隐式转换可能导致很难发现的问题
- 整数类型：可以使用 AUTO_INCREMENT
- ENUM 或 SET 类型: 适合存储固定的信息，比如人的性别
- 字符串类型：避免使用字符串类型，消耗空间并且比数字类型慢。使用非连续的递增值作为 id 可能会在插入的时候产生更多的页分裂情况或在 select 时产生随机访问

### mysql schema 设计中的陷阱

- 太多的列： 服务器在收到存储引擎的数据后，需要进行行转换，即将数据解码成各个列，当列数较多时，此时转换成本较大
- 太多的关联：如果希望查询执行得快速且并发性好，单个查询最好在 12 个表以内做关联
- 避免使用 NULL： mysql 会在索引中存储 NULL 值 

### 范式和反范式

- 范式： 每个事实数据只会出现且出现一次

	- 优点：

		- 更新操作比反范式更快
		- 表更小，更好地放进内存里，所以执行操作更快
		- 很少有多余的数据意味着更少需要 distinct 和 group by 语句

	- 缺点:

		- 可能需要更多的关联操作
		- 可能使一些索引策略无效，例如将列存放在不同的表中，而这些列本可以属于同一个索引

- 范式： 信息冗余，可能存储在多个地方

	- 优点：

		- 避免关联，并且因为不需要关联表。当数据比内存大时，避免关联可以减少随机 IO
		- 可以使用更有效的索引策略

	- 缺点:

		- 数据冗余，占用更多的存储空间以及写入速度较慢

- 混用范式化和反范式化

	- 最常见的反范式化数据的方法是复制或者缓存

- 物化视图
- 计数器表

	- create table hit_counter {  cnt int unsigned not null  } engine = innodb; 此时只有一行记录，每次更新需要获取排他锁，并发度受到限制
	- create table hit_counter { slot tinyint unsigned not null primary key, cnt int unsigned not null  }; 通过预先创建 100 条记录，随机选择槽进行更新 update hit_counter set cnt = cnt + 1 where slot = Rand() * 100;

- 加快 alter table 操作的速度

	- 影子拷贝: 1.按照要求创建一张新表 2.将原表数据拷贝到新表 3.将原表重命名为其他表名，新表命名为原表 
	- 所有的 modify column 都会导致表重建，而 alter column 则不会

## 创建高性能的索引

### 索引基础

- 索引是用于快速找到记录的一种数据结构
- 存储引擎通过索引快速地找到对应值，然后根据匹配的索引记录找到对应的数据行
- 多列索引只能最高效地使用最左前缀列，创建一个包含两个列的索引和创建两个包含一个列的索引是大不相同的

### 索引的类型

- B-Tree 索引

	- 其实很多存储引擎使用的是 B+ Tree 索引，即每个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历

- myisam 通过前缀压缩技术使得索引更小，而 innodb 则按照原格式进行存储。再如 myisam 索引通过数据的物理位置索引被索引的行，而 innodb 则根据主键引用被索引的行
- 因为索引中的节点是有序的，索引除了按值查找以外，索引还可用于查询中的 order by 操作
- 多列索引中如果使用某列范围查询，则该列后面的列索引将不会生效。如 (name, age, sex) 索引对 name > 10 进行搜索，则 age, sex 将不再使用索引 

### 索引的优点

- 1.大大减少了服务器需要扫描的数据量
- 2.索引可以帮助服务器避免排序和临时表
- 3.索引可以将随机 I/O 变为顺序 I/O
- 三星索引原则： 1.将相关的记录放在一起得一星 2.索引中的数据顺序与查找中的排序顺序一致获得两星 3.索引中的列包含了查询中需要的全部列则获得三星

### 索引列不能是表达式的一部分

*XMind - Trial Version*